# Optimal sort
* Рассмотрим оптимальный путь в графе состояний
Состояние включает: массив + динамически необходимые данные
Состояние рабивается на два типа:
1. Состояние оптимального процесса сортировки (optimal_sort)
2. Состояние неоптимального процесса сортировки 
  (insertion_sort, merge_sort, ...) for length(array) > k
    where k размер массива начиная с которого процесс сортировки перестает быть
    самым оптимальным с точки зрения теории игр (наилучший результат для наихудших входных данных)


# Динамически необходимые данные:
### Merge sort
```cpp
unsigned startIndex, unsigned endIndex
```
### Selection sort
```cpp
unsigned startIndex
```

### Insertion sort

### Quick sort
* Значение разделителя m

### Bubble sort
```cpp

```

# Philosophy ideas
* Нужно оставлять простанство для ошибок
  1. Алгоритм должен оставлять пространство для неоптимальных стратегий
  2. Разработчик должен оставлять пространство для ошибок алгоритма

* Следует разделять процесс поиска решения (как отсортировать массив)
  от непосредственно процесса сортировки.
  Для каждого из процессов могут быть составлены графы представления,
  которые в частном случае могут являться деревьями.

* Следует обратить внимание на понятия, которые (эффективно) применимы только для
  отдельного класса алгоритмов.
  Например: Есть предикат `сортировка осталяет одинаковые ключи в исходном порядке`. Он выполняется не для всех реализаций одного и того же алгоритма сортировки.
  Т.е. можно формулировать кроме 3-х процессов:
  1. процесс выполнения задачи (сортировки)
  2. процесс поиска решения (поиск теоретико-игровой оптимальной стратегии)
  Ещё процесс:
  3. процесс расширения возможностей (поиск теорем которые позволяют более `оптимально` находить теоретико-игровую оптимальную стратегию)
    1. Инвариантов
    2. Потенциально полезных предикатов
    3. и других вычислительно-полезных объектов

* (1 <= 2 <= 3 <= ...) эти процессы относяться друг к другу как функция и её производная
  (f <= f' <= f'' <= ...) по аналогии с оператором `дифференцирования` можно ввести оператор `аналитического прыжка (перехода на один уровень выше)`

* Важно фокусироваться на поиске канонических решений нестандартных задач:
  например: 
  1. Распознавание параметров окружности по данной картинке (используя понятия теории игр)
  2. Кононическое решение (только теория вероятностей) распознавания количества
  гауссиан, которые могли создать данный набор точек
  (Можно произвольные распределения рассмотреть например uniform)
  3. Задачи на разделение топологических состояний:
    1. Построение списка простых узлов (теория узлов)
    2. Построение списка вариантов взаимного расположения N окружностей (С учётом и без учёта совпадения границ)
  4. Задачи на делёж пирога(генерация алгоритма оптимального дележа для N человек с различными условиями дележа (аксиомы дележа))

* Стоит обратить внимание на `вилки` - пара различных способов доказательства одного и того же факта в разных понятийных пространствах
  Пример:
  Способ 1: свойство Artin's Relation (bᵢ bᵢ₊₁ bᵢ = bᵢ₊₁ bᵢ bᵢ₊₁) в теории кос в контексте группы Braids
  Способ 2: геометрическое доказательство этого свойства
  Примечание:
  Часто для того чтобы `уложить в голове` незнакомый материал хочется
    найти альтернативных способ докательства т.е. создать `вилку`
  Т.е. `вилка` может быть полезна с практической стороны как вычислительно-полезный объект

  По сути (формально) `вилка` - это пара квазиоптимальных путей в графе `типов термов` (логических утверждений) связанных леммами как стрелками
  